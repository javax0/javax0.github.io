---

title: Documenting REST APIs
layout: posta
comments: on
---



= Documenting REST APIs

== 1. Introduction

There is an ongoing debate among the people focusing on software documentation about the best way to document API.
One approach says that you create the document first, and then the developers develop the code implementing the definitions.
The other approach suggests using the source code as documentation.
It would extend the source code with special comments used to generate the human-readable documentation.

In this article, I will discuss the pros and the cons of the two approaches a bit, and then I will suggest one mixing the two in the middle ground letting you move as many documentation fragments into the code as you like.

== 2. Should APIs be documented with code?

When we talk about putting a document into the code, we talk about the text used to generate the product.
A software product is a set of text files fed into different transformations resulting in

. executable environment, and

. human consumable documentation.

The first one includes the machine code, the configuration of the environment, and generally everything needed technically to have functioning software.
The second is necessary to empower the users to facilitate the software.

=== 2.1. Separate Documentation and Source

.Separate Documentation and Source
image::https://raw.githubusercontent.com/javax0/javax0.github.io/master/assets/images/2024-10-09-01.png[width=60%]

Some of the text files in the software product are used to generate the executable environment, while others are part of the documentation.
Historically, these two sets are separate and are maintained by different people: software developers and documentarians.
The text files used to create the executable are called program source code, or source in short; the other is called documentation.
These have different traits.

* Source code is formal, usually written in a programming language, consumed by programs, and it has to be precise.
* Documentation is written for human readers, uses natural language, and it has to focus on clarity, simplicity, and usability more than precision.

One can say that documentation is the code executed by the human "processors" to operate and use the code executed by the machine processors.

Humans can handle errors in their input and interpret the documentation intelligently.
If there is a typo in the documentation, slight inconsistency, and deviation from the actual product, it may still work.
Humans can interpret, understand, and use imperfect documentation.
It does not mean that documentation with errors in it is okay.
It simply means that it can still be usable with some errors, but you should try not to have errors, of course.

=== 2.2. Mixing Documentation and Source

.Mixed Documentation and Source
image::https://raw.githubusercontent.com/javax0/javax0.github.io/master/assets/images/2024-10-09-02.png[width=60%]

Modern applications mix the documentation with the source to some extent.
There are clear advantages to doing that.

The source contains information the documentation can rely on.
Why to manually write something into a separate document risking inconsistency that is already in the source.
Automatically extracting the information from the source code and transforming it to a human consumable document should be cheaper than manually follow up the change in the source every time to mirror it into the documentation.

Part of the documentation is strongly tied to the code and hence maintained by the developers.
Logical to tie the documentation to the code by placing them in the same text file.
It is less likely to skip the update of the related document for a changing code when the document text is in the same place, the same file.

There are also drawbacks to mixing the document with the source code.
Documentarians are not necessarily developers.
It may be a barrier to edit a text in a source file that is a part of the code.
It may require specialized skills and privileges to modify the source code, even if only the documentation part of it.

It also introduces a new possibility for the process of the documentation: it may fail.

Conventional documentation is a simple conversion process that rarely fails.
You export the document to PDF or some other output format.

When using a textual document, the conversion may signal an error if there are errors in the markup.
Luckily, documentarians got used to the markup language and to the possibility of such an error.
Using markup instead of WYSIWYG editors starts to be a no-brainer.

When the document is partially in the source code, the situation gets more complex.
The conversion may fail because due to some inconsistency between the documentation and the code.
The documentarian has to understand the code to fix the documentation.

While this can be a barrier to overcome, you can also see this as an advantage.
It can provide a semantic check on the documentation which was only available investing manual reviews before these tools.

=== 2.3. Mixed parts

When we talk about source code as part of the documentation, we can separate three different parts of the text.

. One part is pure documentation included in the source code, denoted with the blue color of the diagram _"Mixed Documentation and Source"_
If there is any change in this text, typically a comment, the code will still result in the same executable.

. The second part is actual source code used by the documentation.
It is denoted with red.
This part is the actual code that gets into the executable but also affects the documentation.

. The third part is represented by the blue are striped representing the source affecting the documentation but not the executable.
This part of the documentation is meta-information helping the documentation generator to create the human-readable documentation from the source code.
It is usually a comment from the program point of view

=== 2.4. Simple Examples of Mixing

The most well-known examples of mixing documentation and source are JavaDoc and Doxygen.
Not so well-known, but the first such application -- I could find -- was Perl POD documentation from 1989.
The newer technologies  are GoDoc, RDoc, PHPDoc, XML Comments in C#, and many others, including the already mentioned Javadoc and Doxygen.

Another example is the Swagger/OpenAPI.
The Swagger specification usually uses YAML to describe the API.
This description contains technical parameters (source), and human-readable descriptions (documentation).
The documentation is handy for the maintainer when they write the code implementing the API.
At the same time, the generated documentation is useful for the users of the API.

However, the users of the API need extra information.
The application API is only an interface to an application that can by itself be a complex subject.
The documentation has to explaimn the application purpose, use, differetn use cases, and so on.
This information is not part of the Swagger specification.
Technically, you can put it into the Swagger specification, but it is not the best place for it.

=== 2.5. Modern Way of Mixing

The modern way of mixing documentation and source code is to use a tool that can combine the documentation markup with the information that comes from the code.
There are many different tools that can do this.
Most of these tools support textual, markup formatted document extending the basic markup language.
The actual execution can happen as a preprocessor or modifying the markup processor.

image::https://raw.githubusercontent.com/javax0/javax0.github.io/master/assets/images/2024-10-09-03.png[width=60%]

Using the extra meta-markup language has drawbacks.

* It is an extra language to learn.

* It is simpler to copy a configuration parameter name into the documentation than adding meta information to the code and referencing it from the documentation.

* Getting warnings or errors warning about inconsistencies between the documentation and the code can be annoying.

At the same time, these can also be advantages.
Maybe except the first one.

If you do not copy the configuration name but reference it, the documentation will remain consistent when the developer changes it.
The warning about inconsistencies can be a good thing.
While it may be annoying to get a warning, it is better to get a warning than to have dormant inconsistencies in the documentation.

In the following section I will show a few examples of how you can handle these situations using the Jamal meta markup document processor.
It is only fair to mention that I am the author of Jamal.
There are other tools that you can use, and you should choose the one that fits your needs the best.

=== 2.6. Examples Using Jamal

Jamal is a general purpose meta-markup processor.
It is a Java application, but this should be the last thing you should care about.
It works on Linux, macOS, and Windows.
The installation is simple.
You download the installation kit for your architecture, start it, click a few times on continue, and there you go.

The conversion can be done from the command line, but it is also integrated into IntelliJ Asciidoctor plugin and AsciidocFX editor.
In these cases you can edit Asciidoc and Markdown documents WYSIWYG including the Jamal meta-markup commands, and the conversion is done automatically.

NOTE: When you edit a Markdown document the meta markup preprocessor will convert it to Asciidoc in the memory of the editor and the editor will think that you edit a Asciidoc document and display it formatted.
This is a little workaround needed because the Markdown plugin for IntelliJ does not support preprocessor integration.
Similarly, you can edit XML and other formats with Jamal meta markup and they will be formatted through the Asciidoctor plugin.

==== 2.6.1. Consistency Check

The simplest example is a consistency check.

Some segments of the documentation are closely related to some specific part of the source code.
In that case it would be nice to have a warning if the part of the source code has changed since the documentation was updated.

Let's have a look at an example!

NOTE: The URLs in this article point to a specific commit in the repositories so that the examples are stable.

The source code for the documentation of the Jamal IO package at line 290

https://github.com/verhas/jamal/blob/c96d64674defb8c86d0000083f5649292ba2853c/jamal-io/README.adoc.jam#L290

contains the following line:

[source,text]
----
{%@snip:check id=java_echo_version hashCode=5dd285e7%}
----

The Java code `TestExec.java` at line 24

https://github.com/verhas/jamal/blob/c96d64674defb8c86d0000083f5649292ba2853c/jamal-io/src/test/java/javax0/jamal/io/TestExec.java#L24

contains the following lines:


[source,java]
----
        // tag::java_echo_version[]
        System.setProperty("exec", "java");
        // end::java_echo_version[]
----

The documentation includes these lines verbatim as a demonstration.
It also explains what the code does.
What happens when the code changes and the explanation becomes inconsistent with the new code?
There is no way (currently) to update the document without manual, human work, but at least we can decet the possible inconsistency.
The `snip:check` meta-markup calculates the actual hash code of the snippet and compares it to the hash code stored in the meta-markup.
If it is different, the processing of the document will issue a warning, and the documentarian has a change to update the document, make it consistent with the actual version of the code and then update the hash code.
(The error message contains the correct hash code and even a `sed` command to update the document with a single command.)

The meta-markup can check against the hash code or the number of lines in a snippet or in a whole file, increasing the coupling between the documentation and the code resulting in better consistency.

==== 2.6.2. Include Code to Documentation

The next example is when the documentation includes part of the actual code, but not as a code sample.
The Jamal meta-markup processor has many modules, including one implementing a simple BASIC-like programming language.
This programming language has keywords.
The keywords are defined in a Java source file called `Lexer.java` at line 16:

https://github.com/verhas/jamal/blob/c8486d51f622fb4bda80d5b12b0d150582637646/jamal-prog/src/main/java/javax0/jamal/prog/analyzer/Lexer.java#L16


[source,java]
----
final static private Set<String> RESERVED = Set.of(
        //snipline KEYWORDS
        "if", "else", "elseif", "then", "endif", "while", "wend", "for", "next", "do", "until", "and", "or", "not", "to", "step", "end"
);
----

The documentation

https://github.com/verhas/jamal/blob/c8486d51f622fb4bda80d5b12b0d150582637646/jamal-prog/README.adoc.jam#L438

includes the list of the keywords with the line:

[source,text]
----
The keywords are {%#replace (regex) /{%@snip KEYWORDS%}/"/`/%}.
----

The Java comment `snipline` signals for the processor that the next line is a snippet that will or may be included in the documentation with the name `KEYWORDS`.
The documentation includes the snippet with the `snip` meta-markup and also transforms it replacing the double quotes to back tick.
This essentially will list the keywords which are in the code without copying them into the documentation manually.
The "copy" will be done by the meta-markup processing.
If there ever is a change in the list of the keywords in the code, the documentation will be updated automatically.

==== 2.6.3. Fetch Version Number

Another example is fetching version numbers from the `pom.xml` file.
Documentations many times say "latest version in sample codes, or at other places, when they are talking about the actual version.
Why tell the reader to look at the release history or the `pom.xml` file when they read the documentation?
Reading the documentation should be frictionless, without the need to jump to other places.
Getting the version information from some place is not the task of the reader.
It can be done by the documentation generator.

The same `README.adoc.jam` file we used in the previous example contains the lines:

[source,text]
-----
{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\

[source,xml]
----
<dependency>
<groupId>com.javax0.jamal</groupId>
<artifactId>{%pom /project/artifactId/text()%}</artifactId>
<version>{%VERSION%}</version>
</dependency>
----
-----

This fetches the version number from the `pom.xml` file and uses it in the documentation.

==== 2.6.4. Documentation in the Code

Sometimes it makes sense to include part of the documentation inside the source code.
The example in this case is the documentation of the parameter options for the `for` meta-markup command.

The source code that implements the parameter option handling is

https://github.com/verhas/jamal/blob/c8486d51f622fb4bda80d5b12b0d150582637646/jamal-core/src/main/java/javax0/jamal/builtins/ForState.java#L30

and it contains the code


[source,java]
----
    public ForState(Scanner.ScannerObject scanner, Processor processor) {
        this.processor = processor;
        // snippet parops_for
        separator = scanner.str("$forsep", "separator", "sep").defaultValue(",");
        // can define the separator if it is different from the default, which is `,` comma.
        // The value is used as a regular expression giving very versatile possibilities.
        subSeparator = scanner.str("$forsubsep", "subseparator", "subsep").defaultValue("\\|");
        // can define the subseparator if it is different from the default, which is `|` pipe.
        // It is used when there are multiple variables in the loop.
        // Similarly to the separator, the value is used as a regular expression.
        trim = scanner.bool("trimForValues", "trim");
        // is a boolean paror.
        // If it is present and `true`, then the values are trimmed, the spaces are removed from the beginning and the end.
        skipEmpty = scanner.bool("skipForEmpty", "skipEmpty");
        // is a boolean parameter.
        // If it is present and `true`, then the empty values are skipped.
        lenient = scanner.bool("lenient");
        // is a boolean parameter.
        // If it is present and `true`, then the number of the values in the value list is not checked against the number of the variables.
        evalValueList = scanner.bool("evaluateValueList", "evalist");
        // is a boolean parameter.
        // If it is present and `true`, then the value list is evaluated as a macro before spling it up to values.
        join = scanner.str("$forjoin", "join").defaultValue("");
        // is used to join the values when the values are joined together.
        // The default is the empty string.
        // end snippet
    }
----

This is the code defining the parameter options, and every line declaring a parameter option programmatically is followed by one or more comment lines describing the option.
What the processing will need is to include the information with some text transformation into the documentation.

The Asciidoc document incorporating the documentation from these lines is

https://github.com/verhas/jamal/blob/c8486d51f622fb4bda80d5b12b0d150582637646/documentation/macros/for.adoc.jam#L74

with the following code:

[source,text]
----
The options are
{%@snip:collect from=../../jamal-core/src/main/%}
{%#replaceLines replace="/.*?scanner\\.\\w+\\((.*?)\\).*/* $1/" replace="/\"/`/" replace=|^\s*//|
{%@snip parops_for%}
%}
----

The `snip:collect` meta-tag instructs the processor to collect the snippets from the source directory.
The following lines reference the snippet named `parops_for` and transforms it with three regular expression search and replace.
First it seeks for the string `scanner` and transforms the program line with a list bullet with the strings, whish are the alternative names of the options.
Then, the next replacement changes the double quotes to back-ticks.
Finally, the last one removes the `//` from the start of the comment lines.

This will result in an itemized list of the options in the documentation.
If there is any other option inserted or one deleted, the list will automatically update and the developed is less likely to forget to add the documentaion because it is right there following the declaration of the parameter option.

==== 2.6.5. Mixing Swagger YAML to Documentation

The last example is mixing the documentation included in the Swagger YAML file with the main documentation.
OpenAPI YAML files define the API of a rest service, and it can contain the documentation of the API.
The documentation of the API, however, is different from the documentation of the application.
The latter can and usually should include the first one.

The example is the OpenAPI YAML file of the AxsessGard application:

https://github.com/serverless-u/AxsessGard/blob/d7bee0fc4ac17e23da3c07ef6b5cb83ed6b5800a/src/main/resources/openapi.yaml

There is nothing special in this file.
It is structured, and since Jamal supports reading YAML structures, there is no need to add snippet markers to the file.

The documentation Asccidoc using the information from the YAML file is

https://github.com/serverless-u/AxsessGard/blob/d7bee0fc4ac17e23da3c07ef6b5cb83ed6b5800a/README.adoc.jam#L127

containig the following lines:

[source,text]
----
{%#yaml:define api={%@include [verbatim] src/main/resources/openapi.yaml%}%}
{%@yaml:format prettyFlow flowStyle=BLOCK%}

{%@yaml:set paths=/api.paths%}

{%!@for $path from paths=
{%!@for $METHOD in (get,post,put)=
{%#if|{%@yaml:get (from=api) (paths['$path'].$METHOD != null)%}|
=== {%@case:upper $METHOD%} `$path`

{%@yaml:get (from=api) (paths['$path'].$METHOD.description)%}
%}
%}%}
----

It

* reads the YAML file while processing the documentation,

* goes through the list of paths in an outer loop,

* goes through each existing method in an inner loop, and

* creates a section for each method in each path, including the description of the method.

This last one is a fairly complex example using very advanced features of the Jamal meta-markup processor.
The result is a documentation that contains the application documentation and the API documentation in one place.
If the API documentation changes, it gets included in the application documentation automatically.

== 3. Conclusion and Summary

In this article we discussed the structure of software documentation, how it is created separately in documentation files and partly in the source code.
We pointed out how the information in the source code can take part in generating the documentation.
Integrating the information from the source code has some hardship, but it also has advantages.
In my opinion, the disadvantages source from:

* Human conservativeness is trying to avoid any new technology to learn.

* The increased complexity of the documentation process, which

** is unavoidable to get better automation supporting consistency and better, automated documentation update,

** partially comes from the immaturity of the currently used tools.

On the other hand, the advantages balance these following the DRY (Don't Repeat Yourself) principle applied in programming for half-century.
I also demonstrated the use of a 20+ years old tool that universal and supports any documentation format.
It presents the opportunity to mix the documentation and the source code in a way that is the best fitting the documentarians.

There are tools.
There are no excuses to manually update the documentation where automation could do it.