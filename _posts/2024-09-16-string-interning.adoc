---


title: Comparing Strings and String Interning
layout: posta
comments: on
---



= Comparing Strings and String Interning

== 1. Introduction

I see a lot of posts on Java Developer Community on LinkedIn asking simple questions.
This is a good way practicing and learning, but there are also some issues.
Asking educational questions needs knowldege of two different areas.

* The subject, in this case Java

* Pedagogy.

Unfortunately, I see many questions that seem the person setting the question lacks one or both of these skills.
In this article I will examine one of such questions and the answer to it.

You can learn a bit of Java, a specific area, which may not really be important but interesting if you are a language enthusiast.
You can also learn a bit of pedagogy, how to ask questions.

I am an expert in Java, but I am not a teacher, so yiu should take with caution my advice on the pedagogy topic.

== 2. The Question at Hand

I copy here the question as a text and also the screen capture.
As you can see, there is no actual question in the post.
It is a code snippet, and the author asks the reader to guess the output.

====
``String str1 = "Hello"; String str2 = str1 + " World"; String str3 = "Hello World"; System.out.println(str2 == str3);``

* true

* false

* NullPointerException

* Compilation Error
====

image::https://raw.githubusercontent.com/javax0/javax0.github.io/master/assets/images/image-2024-09-16-09-07-55-890.png[width=400]

== 3. Explanation

The question is about the comparison of two strings.
There are several levels of understanding you need to answer this question.

The question wants to draw your attention to the difference between `==` and `equals` when comparing strings.
The `==` operator compares the references of the objects, while the `equals` method compares the content of the strings.
That way the concatenated string is not the same instance as the one that is created as a literal.
It implies that the result is `false`.

If you know only this much, you can answer the question.
However, there is more to it.

If you have heard about string interning in Java, you may realize that Java _may_ intern the two strings, and if they are identical during the compilation, then Java will use the same instance for both strings.

For example:

[source,java]
----
"Hello World" == "Hello World"
----

is always true.
Not because the `==` operator compares the content of the strings, but because Java interns the strings during compilation.
These two string literals in the JVM become one single string object.


== 4. String Interning

In layman's term interning means that if the string is moved to a pool of strings maintained by the string class.
If there is a string that is equal to the one to be interned then the one already in the interned pool is used.
That way if two strings equal and they are interned then they will be the same object, meaning that the method `==` will also return `true`.

Java calculates the value of constant expressions (JLS  during compilation, and if the result is a string, these strings will be interned automatically. (Java 22 JLS 3.10.5)
It means that the correct answer can also be `true` in some cases.


== 5. Constant Expression

What is a constant expression?
There is a formal definition in the Java Language Specification, which simplifies to the following:

* A literal is a constant expression.
* A reference to a constant variable is a constant expression.
* A constant expression can be a combination of constant expressions using operators.
* The result of a constant expression is a constant value.

And, as we discussed, contant string values are interned during compilation.
The remaining question is: what are constant variables?

== 6. Constant Variables

"Constant variables" in programming languages represent a glaring contradiction in terms. This phrase commits a egregious assault on linguistic logic - a variable, by definition, is meant to vary, while a constant is inherently unchanging. The juxtaposition of these opposing concepts in a single term is a prime example of how technical jargon can sometimes defy common sense.

This linguistic paradox is far from unique in the tech world. Consider "serverless computing," another term that appears to contradict itself. Despite its name, serverless architecture still relies on servers; it merely abstracts them away from the developer's immediate concern.

Having said that, we can focus on the real meaning.
The JLS defines _"a constant variable is a final variable of primitive type or type String that is initialized with a constant expression."_

== 7. Problems with this Question

Knowing all the topics we discussed above, there are several issues with the question.
We can assume that the code example is a single continuous text in the Java application.
We must assume that there is something before and after it, or else it would not compile.

With that statement, as a side note, we have found a reasoning for the answer "Compilation Error".

If we assume that the code is one continuous part, then the variables are local variables.
The code sample does not show any use of the `final` keyword, therefore, they are not constant variables.
If they are not constant variables, then the expressions using them are not constant expressions, and hence the resulting strings are not constants and not interned during compilation.

This reasoning needs a lot of assumptions.
Now, as for the question: do we want to test the Java knowledge of the person or the dediction skills?
Can we tell from the answer that the person knows Java or can there be other reasons someone gives a wrong answer?

The good answer quality and the knowledge in this question looks very much like the Dunning-Kruger
curve.
You can get a good answer from people who are at the top of the "Mount of Stupidity".
It is not informative.

image::../../assets/images/image-2024-09-16-12-13-01-055.png[width=500]

I do not like this question.

== 8. Full Example

To have a look at the full example, you can check the demonstration code:


[source,java]
----
 1. public class StringInterning {
 2.     static final String staticFinalString1 = "Hello";
 3.     static final String staticFinalString2 = staticFinalString1 + " World";
 4.     static final String staticFinalString3 = "Hello World";
 5.     static String staticString1 = "Hello";
 6.     static String staticString2 = staticString1 + " World";
 7.     static String staticString3 = "Hello World";
 8.     final String finalString1 = "Hello";
 9.     final String finalString2 = finalString1 + " World";
10.     final String finalString3 = "Hello World";
11.     String string1 = "Hello";
12.     String string2 = string1 + " World";
13.     String string3 = "Hello World";
14.
15.     public static void main(String[] args) {
16.         final String localFinalString1 = "Hello";
17.         final String localFinalString2 = localFinalString1 + " World";
18.         final String localFinalString3 = "Hello World";
19.         String localString1 = "Hello";
20.         String localString2 = localString1 + " World";
21.         String localString3 = "Hello World";
22.
23.         System.out.println("staticFinalString2 == staticFinalString3: " + (staticFinalString2 == staticFinalString3));
24.         System.out.println("staticString2 == staticString3: " + (staticString2 == staticString3));
25.         System.out.println("finalString2 == finalString3: " + (new StringInterning().finalString2 == new StringInterning().finalString3));
26.         System.out.println("string2 == string3: " + (new StringInterning().string2 == new StringInterning().string3));
27.         System.out.println("localFinalString2 == localFinalString3: " + (localFinalString2 == localFinalString3));
28.         System.out.println("localString2 == localString3: " + (localString2 == localString3));
29.         System.out.println("localString2.intern() == localString3.intern(): " + (localString2.intern() == localString3.intern()));
30.     }
31. }

----

The code checks the compile time calculation using fields as well as local variables.
The fields are `static` and/or `final`, local variables are either `final` or not.
The code checks object identity, and the result will show (you should run it yourself) that the result is `true` when the variables are "constant".

== 9. Should You Know It All?

The question is not a good one.
It does not reliably test the knowledge of the person answering it.
It tries to ask a question, which is important, but it is easy to answer it wrong with more knowledge.
To be 100% sure needs a lot of technical details, which are "worthless" to know.

_Should you know all the details of the Java language, what constant expressions really are, how interning works and all these extras?_

To be an average Java developer: not really.
It is enough if you understand the practice not to use `==` to compare strings.
Then you are safe.
To answer the question of why is not that important.

Even ChatGPT says that there is no semantic difference between final and effectively final local variables.
(https://chatgpt.com/share/66e7f7e5-e7e0-8009-8d3b-02ad3913386d[ChatGPT session discussing the topic.])
However, you can get the correct answer -- as you can see -- if you ask correctly.

The detailed knowledge may come in handy when you debug something that does not work.
If you want to be perfect in your profession, and you have pride knowing the tools you use.
If you want to be a professional Java developer.

To do the everyday programmign job, you do not need to know it all.

== 10. Conclusion

We got to the end of this useless article detailing subtleties of the Java language.
If you got that far, you may have enjoyed it.
If not, then I do not know why you read it so far.

Anyway, next time you see such a question on LinkedIn, ... just ignore it.