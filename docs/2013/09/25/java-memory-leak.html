<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Java memory leak | Java Deep, mostly Java</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Java memory leak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Java has garbage collector and therefore there is no such things as memory leak.WRONG" />
<meta property="og:description" content="Java has garbage collector and therefore there is no such things as memory leak.WRONG" />
<link rel="canonical" href="https://javax0.github.io/2013/09/25/java-memory-leak.html" />
<meta property="og:url" content="https://javax0.github.io/2013/09/25/java-memory-leak.html" />
<meta property="og:site_name" content="Java Deep, mostly Java" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-09-25T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java memory leak" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2013-09-25T00:00:00+02:00","datePublished":"2013-09-25T00:00:00+02:00","description":"Java has garbage collector and therefore there is no such things as memory leak.WRONG","headline":"Java memory leak","mainEntityOfPage":{"@type":"WebPage","@id":"https://javax0.github.io/2013/09/25/java-memory-leak.html"},"url":"https://javax0.github.io/2013/09/25/java-memory-leak.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://javax0.github.io/feed.xml" title="Java Deep, mostly Java" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Java Deep, mostly Java</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Java Deep</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Java memory leak</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-09-25T00:00:00+02:00" itemprop="datePublished">Sep 25, 2013
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Java has garbage collector and therefore there is no such things as memory leak.WRONG</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This is wrong on many different levels. Although this is true that there is a garbage collector (GC) that collects the memory chunks that are not used anymore this is still not the stone of the philosophers. GC offloads a huge amount of error prone job from the programmers shoulder, but does not solve every problem related to memory allocation. To make the things a bit worse there are constructs in the Java environment that may "trick" the GC to keep some allocated memory as allocated even though our program is not using it any more. After 20 years of programming of C and 7 years of Java (some overlapping) I can state that Java is far better in this aspect than C or C++. Still there is some room for improvement. Until those improvements become reality programmers better know the nuts and bolts of memory handling and the usual pitfalls not to fall into the traps. But first thing first.</p>
</div>
<div class="paragraph">
<p><em>What is a memory leak?</em></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Memory leak is the repetitive allocation of memory without consequential release of it when no longer used, leading to the consumption of ever increasing memory limited by external measures not controlled by the program possibly rendering the execution to a degraded state.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In good old C programming time we talked about memory leak when the program was loosing reference to an allocated memory segment and did not release it. In such a situation the program has no means to get a grab to any handle or pointer to that memory segment to call the run-time function <code>free</code> and as such the memory segment remains allocated, it can not be reused by the program and this way it is totally wasted. The memory is reclaimed by the OS when the process exits, though.</p>
</div>
<div class="paragraph">
<p>This is a very typical memory leak, but the definition I gave above is wider than that. It may happen that the code still has a pointer to the allocated memory but it does not release the memory and at the same time it does not uses it anymore. A programmer may build up a linked list hooking up all memory segments allocated calling <code>malloc</code> still never calling <code>free</code> has the same result. Since the result is the same, it is not really interesting if there is a possibility to get access to the memory pointer which is needed to release it or not if we do not release it anyway. It only affects the way to fix the bug, but in either case bugfixing needs code modification.</p>
</div>
<div class="paragraph">
<p>If we look at Java and the GC you can see that this is nearly impossible to produce the classical memory leak where the program looses all references to the allocated memory and thus looses the possibility to release the memory. In that case the GC recognizes the loose of all references to the allocated memory and does the release process. As a matter of fact, that is the standard way to release the memory in Java: just loose all references to an object and GC will collect it. There are no garbage cans, no selective bins. Just throw it away and they will collect it. This is the very reason why many programmers believe that there is no memory leak when programming in Java. From the practical point of view this is close to correct: there are much less hassle hunting memory leaks when programming in Java than it is when programming C, C++ or any other language that does not have a garbage collector.</p>
</div>
<div class="paragraph">
<p>This is the point where we reach to the question: how can memory leak happen in Java?</p>
</div>
<div class="paragraph">
<p><code>Thread</code> and <code>ThreadLocal</code> storage is a very good candidate for memory leak. You can get a memory leaking applications in five easy steps: (List was composed by Daniel Pryden in a <a href="http://stackoverflow.com/questions/6470651/creating-a-memory-leak-with-java">stackoverflow post</a>.)</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The application creates a long-running thread (or use a thread pool to leak even faster).</p>
</li>
<li>
<p>The thread loads a class via an (optionally custom) <code>ClassLoader</code>.</p>
</li>
<li>
<p>The class allocates a large chunk of memory (e.g. <code>new byte[1000000]</code>), stores a strong reference to it in a static field, and then stores a reference to itself in a <code>ThreadLocal</code>. Allocating the extra memory is optional (leaking the Class instance is enough), but it will make the leak work that much faster.</p>
</li>
<li>
<p>The thread clears all references to the custom class or the <code>ClassLoader</code> it was loaded from.</p>
</li>
<li>
<p>Repeat.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since you have no reference to the class and the loader of it you can not get access to the thread local storage and thus you can not get access to the allocated memory (unless you are desperate enough to use reflection). Still the thread local storage has reference and does not allow GC to collect the memory. Thread local storage is not weak. (Btw: why isn&#8217;t is weak?)</p>
</div>
<div class="paragraph">
<p>If you have never experienced anything like that you may think that this is an extremely artificial scenario composed by an evil brain. The truth is that the pattern was created by nature (well, programmers, but not with the intention to create memory leak) and was distilled to the above simple form debugging applications running in Tomcat. Those are very common in the Java word. Redeploying applications without restarting the Tomcat instance many times caused slow degradation of memory because of exactly the above pattern and there are not too much Tomcat can do against it. The applications should be careful using thread local.</p>
</div>
<div class="paragraph">
<p>You should also be careful when storing large data referenced by static variables. Better avoid static variables if ever you can and better rely on containers you program runs in. They are more flexible than the Java class loader hierarchy. If you store large amount of data in a Map or Set why not to use the weak version of the map or set? If you do not have the key, will you even need the value attached to it?</p>
</div>
<div class="paragraph">
<p>And now the hash maps and sets. If you use objects as keys that does not implement, or implement the methods <code>equals()</code> and <code>hashCode</code> wrong then calling <code>put()</code> will throw your data into a sink hole. You will never be able to recover it from the hash set/map and what is worse you will get duplicates (or better multiplicates) just as many times you put an object into the structure. You just throw your memory into a sinkhole.</p>
</div>
<div class="paragraph">
<p>There are numerous examples of possible memory leaks in Java. Even though they are magnitude less frequent than they are in C, or C++. Usually it is better to have a GC than not having.</p>
</div>
<div class="sect2">
<h3 id="comments-imported-from-wordpress">Comments imported from Wordpress</h3>
<div class="paragraph">
<p><strong>Norbert Madar√°sz</strong> 2013-09-25 15:14:15</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Another term for java memory leak is object loitering: holding strong references to unused objects.</p>
</div>
<div class="paragraph">
<p>There is a nice and simple example of it in Joshua Bloch&#8217;s Effective Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Can you spot the "memory leak"?
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
       return elements[--size];
    }

    /**
    * Ensure space for at least one more element, roughly
    * doubling the capacity each time the array needs to grow.
    */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>"Whenever a class manages its own memory, the programmer should be alert for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out. Another common source of memory leaks is caches."</p>
</div>
<div class="paragraph">
<p>The corrected version of the pop method looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }</code></pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>Third time lucky? | cartesian product</strong> 2013-10-13 19:38:42</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[&#8230;] Java memory leak (javax0.wordpress.com) [&#8230;]</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>Pit</strong> 2013-11-06 20:55:06</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>nice!</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>Ivo</strong> 2014-08-17 21:41:54</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This is truly well explained, having worked in the leak detection domain for years now, it is seldom when I see so clearly expressed thoughts around memory management principles in Java. And whenever one can actually express the memory management principles in more details, they tend to have some systems programming background with C.</p>
</div>
<div class="paragraph">
<p>Anyhow, whenever you stumble upon the next leak suspect in your life, you might consider giving Plumbr (<a href="https://plumbr.eu" class="bare">https://plumbr.eu</a>) a trial run, we would find all the cases described in your post and pinpoint you down to the single line in code where the leak originated.</p>
</div>
<div class="paragraph">
<p>Ivo, the Product guy from Plumbr.</p>
</div>
</blockquote>
</div>
</div>


<!-- Disqus comments section goes here (if comments are enabled) -->

<hr/>
<h1>Comments</h1>
<p>Please leave your comments using Disqus, or just press one of the happy faces.
If for any reason you do not want to leave a comment here, <a href="https://github.com/javax0/javax0.github.io/issues">you can still create a Github ticket</a>.</p>
<div class="comments">
    <div id="disqus_thread"></div>

    <script type="text/javascript">

        /* * * STOP! * * */
        /* You shouldn't need to edit ANYTHING below to get this working! */
        /* Instead, edit the key `disqus.shortname` in _config.yml */

        var disqus_config = function (){
            this.page.url = 'https://javax0.github.io/2013/09/25/java-memory-leak.html';
            this.page.identifier = '/2013/09/25/java-memory-leak.html';
        };

        (function() {
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript'; s.async = true;
            s.src = 'https://javax0.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();

    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>




  </div><a class="u-url" href="/2013/09/25/java-memory-leak.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java Deep, mostly Java</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java Deep, mostly Java</li><li><a class="u-email" href="mailto:peter@verhas.com">peter@verhas.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">verhas</span></a></li><li><a href="https://www.twitter.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">verhas</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>javax0 is a technical Java oriented blog. Whenever I find something interesting, in the mood and feel the power to publish it, you will get it here. Publications are usually released on Wednesday 15:00am GMT. Earlier posts of the blog were published on Javax0 Wordpress Site at https://javax0.wordpress.com</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
